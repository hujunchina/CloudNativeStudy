##### 2020年5月9日 17:16:12

### 目录

1. 容器与镜像
2. 容器生命周期



### 1. 容器与镜像

#### 1.1 什么是容器？

![image-20200509202952961](img\container-struct)

Linux 操作系统中进程特点：

- 进程间可以相互看见，相互通信；
- 使用同一个文件系统，进行读写操作；
- 使用相同的系统资源，如CPU内存

这三个特点会带来三个问题：

- 高级权限的进程会攻击其他进程
- 高级权限进程篡改其他进程的数据
- 资源抢占消耗，导致其他进程无法运行

针对上面三个问题，为进程提供一个独立的运行环境：

- 使用 Namespace 计算实现进程在资源视图上的隔离，让进程可以独立起来
- 使用 chroot 为进程建立一个独立的文件系统
- 使用 Cgroup 来限制资源的使用，可控分配资源

上面的，这些应该如何定义呢？

其实，容器就是一个视图隔离、资源可限制、独立文件系统的进程的集合。

#### 1.2 什么是镜像？

这些容器运行时，需要的文件的集合就是容器镜像。包括配置文件，程序文件，执行文件，数据文件等。

对镜像的改变，称之为 changeset ，可以像 git 一样保留每次更新的细节，实现对镜像的分层修改和镜像数据共享。

好处：

1. 提高分发效率，可以对大镜像拆分小模块
2. 镜像共有部分的复用，A基于B构建，可以直接复用本地的B
3. 节省磁盘存储

#### 1.3 如何构建镜像？

我们使用 dockerfile 来描述构建镜像的动作。

![image-20200509203124445](img\docker-build)

如图所示：

1. FROM 行表示以下的构建步骤基于什么镜像进行构建，正如前面所提到的，镜像是可以复用的；
2. WORKDIR 行表示会把接下来的构建步骤都在哪一个相应的具体目录下进行，其起到的作用类似于 Shell 里面的 cd；
3. COPY 行表示的是可以将宿主机上的文件拷贝到容器镜像内；
4. RUN 行表示在具体的文件系统内执行相应的动作。当我们运行完毕之后就可以得到一个应用了；
5. CMD 行表示使用镜像时的默认程序名字。

再使用 `docker build` 命令执行 dockerfile 构建镜像。

最后统一放在镜像仓库。

#### 1.4 如何运行容器？

- `docker pull` 从镜像仓库中拉取镜像
- `docker images` 查看镜像
- `docker run` 来运行镜像得到想要的容器



### 2. 容器的生命周期

#### 2.1 生命周期

在使用 `docker run` 的时候会选择一个镜像来提供独立的文件系统并指定相应的运行程序。这里指定的运行程序称之为 initial 进程，这个 initial 进程启动的时候，容器也会随之启动，当 initial 进程退出的时候，容器也会随之退出。

因此，容器的生命周期和 inital 进程是一致的。在 inital 父进程下面，可以通过 `docker exec` 执行得到子进程。资源泄露。

容器结束，由于其封闭性，数据会丢失。所以要持久化数据，持久化到指定的目录，这个目录就叫数据卷。

直接 bind 挂载到容器内，或交给运行引擎管理。



### 3. 容器项目架构

#### 3.1 moby 容器引擎架构

![image-20200509203249554](img\moby-containerd)

moby daemon 对容器、镜像、网络、数据卷管理，其依赖 containerd 服务，其底层是 containerd shim 模块（类似守护进程）。

1. shim 通过插件的形式对不同的容器灵活管理
2. shim 可被 containerd 动态接管，即插即用感
3. 利用 shim 可以对 moby 和containerd 进行原地升级



### 4. 容器 vs VM

VM 利用 Hypervisor 虚拟化技术来模拟 CPU、内存等硬件资源，这样就可以在宿主机上建立一个 Guest OS，这是常说的安装一个虚拟机。

每一个 Guest OS 都有一个独立的内核，比如 Ubuntu、CentOS 甚至是 Windows 等，在这样的 Guest OS 之下，每个应用都是相互独立的，VM 可以提供一个更好的隔离效果。但这样的隔离效果需要付出一定的代价，因为需要把一部分的计算资源交给虚拟化，这样就很难充分利用现有的计算资源，并且每个 Guest OS 都需要占用大量的磁盘空间，比如 Windows 操作系统的安装需要 10~30G 的磁盘空间，Ubuntu 也需要 5~6G，同时这样的方式启动很慢。正是因为虚拟机技术的缺点，催生出了容器技术。

容器是针对于进程而言的，因此无需 Guest OS，只需要一个独立的文件系统提供其所需要文件集合即可。所有的文件隔离都是进程级别的，因此启动时间快于 VM，并且所需的磁盘空间也小于 VM。当然了，进程级别的隔离并没有想象中的那么好，隔离效果相比 VM 要差很多。

